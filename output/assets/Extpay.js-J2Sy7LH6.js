"use strict";var W=function(){var B=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function F(d){var f={exports:{}};return d(f,f.exports),f.exports}var g=F(function(d,f){(function(y,v){v(d)})(typeof globalThis<"u"?globalThis:typeof self<"u"?self:B,function(y){if(typeof browser>"u"||Object.getPrototypeOf(browser)!==Object.prototype){const v="The message port closed before a response was received.",S="Returning a Promise is the preferred way to send a reply from an onMessage/onMessageExternal listener, as the sendResponse will be removed from the specs (See https://developer.mozilla.org/docs/Mozilla/Add-ons/WebExtensions/API/runtime/onMessage)",C=h=>{const _={alarms:{clear:{minArgs:0,maxArgs:1},clearAll:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getAll:{minArgs:0,maxArgs:0}},bookmarks:{create:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},getChildren:{minArgs:1,maxArgs:1},getRecent:{minArgs:1,maxArgs:1},getSubTree:{minArgs:1,maxArgs:1},getTree:{minArgs:0,maxArgs:0},move:{minArgs:2,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeTree:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}},browserAction:{disable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},enable:{minArgs:0,maxArgs:1,fallbackToNoCallback:!0},getBadgeBackgroundColor:{minArgs:1,maxArgs:1},getBadgeText:{minArgs:1,maxArgs:1},getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},openPopup:{minArgs:0,maxArgs:0},setBadgeBackgroundColor:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setBadgeText:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},browsingData:{remove:{minArgs:2,maxArgs:2},removeCache:{minArgs:1,maxArgs:1},removeCookies:{minArgs:1,maxArgs:1},removeDownloads:{minArgs:1,maxArgs:1},removeFormData:{minArgs:1,maxArgs:1},removeHistory:{minArgs:1,maxArgs:1},removeLocalStorage:{minArgs:1,maxArgs:1},removePasswords:{minArgs:1,maxArgs:1},removePluginData:{minArgs:1,maxArgs:1},settings:{minArgs:0,maxArgs:0}},commands:{getAll:{minArgs:0,maxArgs:0}},contextMenus:{remove:{minArgs:1,maxArgs:1},removeAll:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},cookies:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:1,maxArgs:1},getAllCookieStores:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},devtools:{inspectedWindow:{eval:{minArgs:1,maxArgs:2,singleCallbackArg:!1}},panels:{create:{minArgs:3,maxArgs:3,singleCallbackArg:!0},elements:{createSidebarPane:{minArgs:1,maxArgs:1}}}},downloads:{cancel:{minArgs:1,maxArgs:1},download:{minArgs:1,maxArgs:1},erase:{minArgs:1,maxArgs:1},getFileIcon:{minArgs:1,maxArgs:2},open:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},pause:{minArgs:1,maxArgs:1},removeFile:{minArgs:1,maxArgs:1},resume:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},extension:{isAllowedFileSchemeAccess:{minArgs:0,maxArgs:0},isAllowedIncognitoAccess:{minArgs:0,maxArgs:0}},history:{addUrl:{minArgs:1,maxArgs:1},deleteAll:{minArgs:0,maxArgs:0},deleteRange:{minArgs:1,maxArgs:1},deleteUrl:{minArgs:1,maxArgs:1},getVisits:{minArgs:1,maxArgs:1},search:{minArgs:1,maxArgs:1}},i18n:{detectLanguage:{minArgs:1,maxArgs:1},getAcceptLanguages:{minArgs:0,maxArgs:0}},identity:{launchWebAuthFlow:{minArgs:1,maxArgs:1}},idle:{queryState:{minArgs:1,maxArgs:1}},management:{get:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},getSelf:{minArgs:0,maxArgs:0},setEnabled:{minArgs:2,maxArgs:2},uninstallSelf:{minArgs:0,maxArgs:1}},notifications:{clear:{minArgs:1,maxArgs:1},create:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:0},getPermissionLevel:{minArgs:0,maxArgs:0},update:{minArgs:2,maxArgs:2}},pageAction:{getPopup:{minArgs:1,maxArgs:1},getTitle:{minArgs:1,maxArgs:1},hide:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setIcon:{minArgs:1,maxArgs:1},setPopup:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},setTitle:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0},show:{minArgs:1,maxArgs:1,fallbackToNoCallback:!0}},permissions:{contains:{minArgs:1,maxArgs:1},getAll:{minArgs:0,maxArgs:0},remove:{minArgs:1,maxArgs:1},request:{minArgs:1,maxArgs:1}},runtime:{getBackgroundPage:{minArgs:0,maxArgs:0},getPlatformInfo:{minArgs:0,maxArgs:0},openOptionsPage:{minArgs:0,maxArgs:0},requestUpdateCheck:{minArgs:0,maxArgs:0},sendMessage:{minArgs:1,maxArgs:3},sendNativeMessage:{minArgs:2,maxArgs:2},setUninstallURL:{minArgs:1,maxArgs:1}},sessions:{getDevices:{minArgs:0,maxArgs:1},getRecentlyClosed:{minArgs:0,maxArgs:1},restore:{minArgs:0,maxArgs:1}},storage:{local:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}},managed:{get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1}},sync:{clear:{minArgs:0,maxArgs:0},get:{minArgs:0,maxArgs:1},getBytesInUse:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}}},tabs:{captureVisibleTab:{minArgs:0,maxArgs:2},create:{minArgs:1,maxArgs:1},detectLanguage:{minArgs:0,maxArgs:1},discard:{minArgs:0,maxArgs:1},duplicate:{minArgs:1,maxArgs:1},executeScript:{minArgs:1,maxArgs:2},get:{minArgs:1,maxArgs:1},getCurrent:{minArgs:0,maxArgs:0},getZoom:{minArgs:0,maxArgs:1},getZoomSettings:{minArgs:0,maxArgs:1},goBack:{minArgs:0,maxArgs:1},goForward:{minArgs:0,maxArgs:1},highlight:{minArgs:1,maxArgs:1},insertCSS:{minArgs:1,maxArgs:2},move:{minArgs:2,maxArgs:2},query:{minArgs:1,maxArgs:1},reload:{minArgs:0,maxArgs:2},remove:{minArgs:1,maxArgs:1},removeCSS:{minArgs:1,maxArgs:2},sendMessage:{minArgs:2,maxArgs:3},setZoom:{minArgs:1,maxArgs:2},setZoomSettings:{minArgs:1,maxArgs:2},update:{minArgs:1,maxArgs:2}},topSites:{get:{minArgs:0,maxArgs:0}},webNavigation:{getAllFrames:{minArgs:1,maxArgs:1},getFrame:{minArgs:1,maxArgs:1}},webRequest:{handlerBehaviorChanged:{minArgs:0,maxArgs:0}},windows:{create:{minArgs:0,maxArgs:1},get:{minArgs:1,maxArgs:2},getAll:{minArgs:0,maxArgs:1},getCurrent:{minArgs:0,maxArgs:1},getLastFocused:{minArgs:0,maxArgs:1},remove:{minArgs:1,maxArgs:1},update:{minArgs:2,maxArgs:2}}};if(Object.keys(_).length===0)throw new Error("api-metadata.json has not been included in browser-polyfill");class $ extends WeakMap{constructor(r,t=void 0){super(t),this.createItem=r}get(r){return this.has(r)||this.set(r,this.createItem(r)),super.get(r)}}const k=s=>s&&typeof s=="object"&&typeof s.then=="function",N=(s,r)=>(...t)=>{h.runtime.lastError?s.reject(h.runtime.lastError):r.singleCallbackArg||t.length<=1&&r.singleCallbackArg!==!1?s.resolve(t[0]):s.resolve(t)},w=s=>s==1?"argument":"arguments",L=(s,r)=>function(i,...c){if(c.length<r.minArgs)throw new Error(`Expected at least ${r.minArgs} ${w(r.minArgs)} for ${s}(), got ${c.length}`);if(c.length>r.maxArgs)throw new Error(`Expected at most ${r.maxArgs} ${w(r.maxArgs)} for ${s}(), got ${c.length}`);return new Promise((A,u)=>{if(r.fallbackToNoCallback)try{i[s](...c,N({resolve:A,reject:u},r))}catch(a){console.warn(`${s} API method doesn't seem to support the callback parameter, falling back to call it without a callback: `,a),i[s](...c),r.fallbackToNoCallback=!1,r.noCallback=!0,A()}else r.noCallback?(i[s](...c),A()):i[s](...c,N({resolve:A,reject:u},r))})},E=(s,r,t)=>new Proxy(r,{apply(i,c,A){return t.call(c,s,...A)}});let P=Function.call.bind(Object.prototype.hasOwnProperty);const j=(s,r={},t={})=>{let i=Object.create(null),c={has(u,a){return a in s||a in i},get(u,a,x){if(a in i)return i[a];if(!(a in s))return;let l=s[a];if(typeof l=="function")if(typeof r[a]=="function")l=E(s,s[a],r[a]);else if(P(t,a)){let T=L(a,t[a]);l=E(s,s[a],T)}else l=l.bind(s);else if(typeof l=="object"&&l!==null&&(P(r,a)||P(t,a)))l=j(l,r[a],t[a]);else if(P(t,"*"))l=j(l,r[a],t["*"]);else return Object.defineProperty(i,a,{configurable:!0,enumerable:!0,get(){return s[a]},set(T){s[a]=T}}),l;return i[a]=l,l},set(u,a,x,l){return a in i?i[a]=x:s[a]=x,!0},defineProperty(u,a,x){return Reflect.defineProperty(i,a,x)},deleteProperty(u,a){return Reflect.deleteProperty(i,a)}},A=Object.create(s);return new Proxy(A,c)},O=s=>({addListener(r,t,...i){r.addListener(s.get(t),...i)},hasListener(r,t){return r.hasListener(s.get(t))},removeListener(r,t){r.removeListener(s.get(t))}});let b=!1;const R=new $(s=>typeof s!="function"?s:function(t,i,c){let A=!1,u,a=new Promise(M=>{u=function(p){b||(console.warn(S,new Error().stack),b=!0),A=!0,M(p)}}),x;try{x=s(t,i,u)}catch(M){x=Promise.reject(M)}const l=x!==!0&&k(x);if(x!==!0&&!l&&!A)return!1;const T=M=>{M.then(p=>{c(p)},p=>{let D;p&&(p instanceof Error||typeof p.message=="string")?D=p.message:D="An unexpected error occurred",c({__mozWebExtensionPolyfillReject__:!0,message:D})}).catch(p=>{console.error("Failed to send onMessage rejected reply",p)})};return T(l?x:a),!0}),e=({reject:s,resolve:r},t)=>{h.runtime.lastError?h.runtime.lastError.message===v?r():s(h.runtime.lastError):t&&t.__mozWebExtensionPolyfillReject__?s(new Error(t.message)):r(t)},n=(s,r,t,...i)=>{if(i.length<r.minArgs)throw new Error(`Expected at least ${r.minArgs} ${w(r.minArgs)} for ${s}(), got ${i.length}`);if(i.length>r.maxArgs)throw new Error(`Expected at most ${r.maxArgs} ${w(r.maxArgs)} for ${s}(), got ${i.length}`);return new Promise((c,A)=>{const u=e.bind(null,{resolve:c,reject:A});i.push(u),t.sendMessage(...i)})},o={runtime:{onMessage:O(R),onMessageExternal:O(R),sendMessage:n.bind(null,"sendMessage",{minArgs:1,maxArgs:3})},tabs:{sendMessage:n.bind(null,"sendMessage",{minArgs:2,maxArgs:3})}},m={clear:{minArgs:1,maxArgs:1},get:{minArgs:1,maxArgs:1},set:{minArgs:1,maxArgs:1}};return _.privacy={network:{"*":m},services:{"*":m},websites:{"*":m}},j(h,o,_)};if(typeof chrome!="object"||!chrome||!chrome.runtime||!chrome.runtime.id)throw new Error("This script should only be loaded in a browser extension.");y.exports=C(chrome)}else y.exports=browser})});typeof window<"u"&&window.addEventListener("message",d=>{d.origin==="https://extensionpay.com"&&d.source==window&&(d.data==="fetch-user"||d.data==="trial-start")&&g.runtime.sendMessage(d.data)},!1);function I(d){const f="https://extensionpay.com",y=`${f}/extension/${d}`;function v(e){return new Promise(n=>setTimeout(n,e))}async function S(e){try{return await g.storage.sync.get(e)}catch{return await g.storage.local.get(e)}}async function C(e){try{return await g.storage.sync.set(e)}catch{return await g.storage.local.set(e)}}g.management&&g.management.getSelf().then(async e=>{if(!e.permissions.includes("storage")){var n=e.hostPermissions.concat(e.permissions);throw`ExtPay Setup Error: please include the "storage" permission in manifest.json["permissions"] or else ExtensionPay won't work correctly.

You can copy and paste this to your manifest.json file to fix this error:

"permissions": [
    ${n.map(o=>`"    ${o}"`).join(`,
`)}${n.length>0?",":""}
    "storage"
]
`}}),S(["extensionpay_installed_at","extensionpay_user"]).then(async e=>{if(e.extensionpay_installed_at)return;const n=e.extensionpay_user,o=n?n.installedAt:new Date().toISOString();await C({extensionpay_installed_at:o})});const h=[],_=[];async function $(){var e={},n;if(g.management)n=await g.management.getSelf();else if(g.runtime)n=await g.runtime.sendMessage("extpay-extinfo"),n||(n={installType:!("update_url"in g.runtime.getManifest())?"development":"normal"});else throw"ExtPay needs to be run in a browser extension context";n.installType=="development"&&(e.development=!0);const o=await fetch(`${y}/api/new-key`,{method:"POST",headers:{Accept:"application/json","Content-type":"application/json"},body:JSON.stringify(e)});if(!o.ok)throw o.status,`${f}/home`;const m=await o.json();return await C({extensionpay_api_key:m}),m}async function k(){const e=await S(["extensionpay_api_key"]);return e.extensionpay_api_key?e.extensionpay_api_key:null}const N=/^\d\d\d\d-\d\d-\d\dT/;async function w(){var e=await S(["extensionpay_user","extensionpay_installed_at"]);const n=await k();if(!n)return{paid:!1,paidAt:null,installedAt:e.extensionpay_installed_at?new Date(e.extensionpay_installed_at):new Date,trialStartedAt:null};const o=await fetch(`${y}/api/user?api_key=${n}`,{method:"GET",headers:{Accept:"application/json"}});if(!o.ok)throw"ExtPay error while fetching user: "+await o.text();const m=await o.json(),s={};for(var[r,t]of Object.entries(m))t&&t.match&&t.match(N)&&(t=new Date(t)),s[r]=t;return s.installedAt=new Date(e.extensionpay_installed_at),s.paidAt&&(!e.extensionpay_user||e.extensionpay_user&&!e.extensionpay_user.paidAt)&&h.forEach(i=>i(s)),s.trialStartedAt&&(!e.extensionpay_user||e.extensionpay_user&&!e.extensionpay_user.trialStartedAt)&&_.forEach(i=>i(s)),await C({extensionpay_user:m}),s}async function L(){var e=await k();return e||(e=await $()),`${y}?api_key=${e}`}async function E(e,n,o){if(g.windows&&g.windows.create){const m=await g.windows.getCurrent(),s=Math.round((m.width-n)*.5+m.left),r=Math.round((m.height-o)*.5+m.top);try{g.windows.create({url:e,type:"popup",focused:!0,width:n,height:o,left:s,top:r})}catch{g.windows.create({url:e,type:"popup",width:n,height:o,left:s,top:r})}}else window.open(e,null,`toolbar=no,location=no,directories=no,status=no,menubar=no,width=${n},height=${o},left=450`)}async function P(){const e=await L();E(e,500,800)}async function j(e){var n=await k();n||(n=await $());var o=`${y}/trial?api_key=${n}`;e&&(o+=`&period=${e}`),E(o,500,650)}async function O(){var e=await k();e||(e=await $());const n=`${y}/reactivate?api_key=${e}`;E(n,500,800)}var b=!1;async function R(){if(!b){b=!0;for(var e=await w(),n=0;n<120;++n){if(e.paidAt)return b=!1,e;await v(1e3),e=await w()}b=!1}}return{getUser:function(){return w()},onPaid:{addListener:function(e){const n=`"content_scripts": [
                {
            "matches": ["${f}/*"],
            "js": ["ExtPay.js"],
            "run_at": "document_start"
        }]`,o=g.runtime.getManifest();if(!o.content_scripts)throw`ExtPay setup error: To use the onPaid callback handler, please include ExtPay as a content script in your manifest.json. You can copy the example below into your manifest.json or check the docs: https://github.com/Glench/ExtPay#2-configure-your-manifestjson

        ${n}`;const m=o.content_scripts.find(s=>s.matches.includes(f.replace(":3000","")+"/*"));if(m){if(!m.run_at||m.run_at!=="document_start")throw`ExtPay setup error: To use the onPaid callback handler, please make sure the ExtPay content script in your manifest.json runs at document start. You can copy the example below into your manifest.json or check the docs: https://github.com/Glench/ExtPay#2-configure-your-manifestjson

        ${n}`}else throw`ExtPay setup error: To use the onPaid callback handler, please include ExtPay as a content script in your manifest.json matching "${f}/*". You can copy the example below into your manifest.json or check the docs: https://github.com/Glench/ExtPay#2-configure-your-manifestjson

        ${n}`;h.push(e)}},openPaymentPage:P,openTrialPage:j,openLoginPage:O,onTrialStarted:{addListener:function(e){_.push(e)}},startBackground:function(){g.runtime.onMessage.addListener(function(e,n,o){if(console.log("service worker got message! Here it is:",e),e=="fetch-user")R();else if(e=="trial-start")w();else if(e=="extpay-extinfo"&&g.management)return g.management.getSelf()})}}}return I}();module.exports=W;
